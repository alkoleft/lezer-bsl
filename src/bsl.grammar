// Корневой элемент модуля - последовательность элементов (процедур, функций, операторов)
@top Module { element* }

// Пропускаемые символы при парсинге (пробелы и однострочные комментарии)
@skip { space | LineComment }

// Определение токенов (лексических единиц)
@tokens {
  // Пробельные символы (пробелы, табы и т.д.)
  space { @whitespace+ }
  
  // Однострочный комментарий, начинается с // и продолжается до конца строки
  LineComment[isolate] {
    "//" ![\n]*
  }

  // Оператор деления (отдельный токен для корректной обработки приоритетов)
  Divide[@name=ArithOp] { "/" }

  // Строка препроцессора (директива компиляции, начинается с #)
  // Сохраняется как токен для возможности анализа потребителями
  Preproc { "#" ![\n]* }

  // Строка аннотации (директивы компилятора / метаданные обработчиков и т.д.)
  // Сохраняется как токен для избежания LR конфликтов при парсинге
  Annotation { "&" ![\n]* }

  // Числовой литерал (целое число или число с плавающей точкой)
  Number {
    @digit+ ("." @digit+)?
  }

  // Строковый литерал: в BSL используются двойные кавычки, экранирование через удвоение ("")
  // Закрывающая кавычка сделана опциональной для поддержки незавершенных строк
  String[isolate] { "\"" (stringContent | "\"\"")* "\""? }
  
  // Многострочная строка в BSL:
  // "строка1
  // |строка2
  // |строка3"
  MultilineString[isolate] {
    "\"" (stringContent | "\"\"")*
    (("\r"? "\n") $[ \t]* "|" (stringContent | "\"\"")*)+
    "\""?
  }

  // Содержимое строки (любые символы кроме кавычек, обратного слэша и переводов строк)
  stringContent { !["\\\n]+ }

  // Литерал даты: 'YYYYMMDD' или 'YYYYMMDDhhmmss' в одинарных кавычках
  Date { "'" @digit@digit@digit@digit@digit@digit@digit@digit (@digit@digit@digit@digit@digit@digit)? "'" }

  // Идентификатор: начинается с буквы или подчеркивания, может содержать буквы, цифры, кириллицу
  Identifier { IdentStart IdentContinue* }
  // Первый символ идентификатора: латинская буква, подчеркивание или кириллица
  IdentStart { @asciiLetter | $[_А-Яа-яЁё] }
  // Последующие символы идентификатора: то же самое плюс цифры
  IdentContinue { IdentStart | @digit }

  // Приоритеты токенов для разрешения неоднозначностей
  @precedence { LineComment, Divide }
  @precedence { MultilineString, String }
  @precedence { space, Identifier }
}

// Приоритеты операций
// assign (присваивание) - с отсечением для избежания конфликтов
@precedence {
  assign @cut
}

// Элемент модуля: может быть строка препроцессора, аннотация, определение метода или оператор
element {
  PreprocLine |
  ProcedureDef |
  FunctionDef |
  Statement
}

// Строка препроцессора
PreprocLine { Preproc }

// Вспомогательное правило: разделенный запятыми список элементов (может быть пустым)
commaSep<content> {
  "" | content ("," content?)*
}

// Вспомогательное правило: разделенный запятыми список элементов (минимум один элемент)
commaSep1<content> {
  content ("," content)*
}

// Объявление переменных: ключевое слово Перем, список спецификаций переменных, точка с запятой
VarDecl { Annotation? kwVar commaSep1<VarSpec> Export { kwExport }? ";" }
// Спецификация переменной: идентификатор и опциональное начальное значение
VarSpec { Identifier ("=" Expression)? }

// Определение процедуры: опционально асинхронная, ключевое слово Процедура, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецПроцедуры
ProcedureDef[closedBy="kwEndProcedure"] {
  Annotation?
  kwAsync? kwProcedure Identifier ParamList Export { kwExport }? Block kwEndProcedure
}

// Определение функции: опционально асинхронная, ключевое слово Функция, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецФункции
FunctionDef[closedBy="kwEndFunction"] {
  Annotation?
  kwAsync? kwFunction Identifier ParamList Export { kwExport }? Block kwEndFunction
}

// Список параметров: в круглых скобках, разделенные запятыми
ParamList { "(" commaSep<Param> ")" }
// Параметр: опционально ключевое слово Знач (передача по значению), затем имя
Param { kwVal? Identifier }

// Блок кода: последовательность операторов, строк препроцессора и аннотаций
Block { (Statement | PreprocLine)* }

// Оператор (statement): различные типы операторов языка
// Помечен как группа для удобства работы с AST
Statement[@isGroup=StatementGroup] {
  IfStmt |                    // Условный оператор
  WhileStmt |                 // Цикл пока
  ForStmt |                   // Цикл для
  TryStmt |                   // Блок обработки исключений
  ExecuteStmt ";" |           // Оператор Выполнить
  AwaitStmt ";" |             // Оператор Ждать
  ContinueStmt ";" |          // Оператор Продолжить
  BreakStmt ";" |             // Оператор Прервать
  GotoStmt ";" |              // Оператор Перейти
  LabelStmt ";" |             // Метка (для оператора Перейти)
  AddHandlerStmt ";" |        // Оператор ДобавитьОбработчик
  RemoveHandlerStmt ";" |     // Оператор УдалитьОбработчик
  ReturnStmt ";" |            // Оператор Возврат
  RaiseStmt ";" |             // Оператор ВызватьИсключение
  VarDecl |                   // Объявление переменных
  ExpressionStmt { Expression ";" } |  // Выражение как оператор
  Assignment ";" |            // Присваивание
  ";"                         // Пустой оператор
}

// Условный оператор: Если ... Тогда ... ИначеЕсли ... Тогда ... Иначе ... КонецЕсли
IfStmt {
  kwIf Expression kwThen Block
  (kwElseIf Expression kwThen Block)*
  (kwElse Block)?
  kwEndIf ";"
}

// Цикл пока: Пока ... Цикл ... КонецЦикла
WhileStmt { kwWhile Expression kwDo Block kwEndDo ";" }

// Цикл для: может быть двух видов:
// 1. Для Каждого ... Из ... (перебор коллекции)
// 2. Для ... = ... По ... (цикл с счетчиком)
ForStmt {
  kwFor (
    kwEach Identifier kwIn Expression |
    Identifier "=" Expression kwTo Expression
  )
  kwDo Block kwEndDo ";"
}

// Блок обработки исключений: Попытка ... Исключение ... КонецПопытки
TryStmt { kwTry Block kwExcept Block kwEndTry ";" }

// Оператор возврата из функции/процедуры: Возврат [значение]
ReturnStmt { kwReturn Expression? }
// Оператор вызова исключения: ВызватьИсключение [значение]
RaiseStmt { kwRaise Expression? }

// Оператор выполнения выражения: Выполнить выражение
ExecuteStmt { kwExecute Expression }

// Оператор ожидания: Ждать выражение
AwaitStmt { kwAwait Expression }

// Оператор продолжения цикла: Продолжить (переход к следующей итерации)
ContinueStmt { kwContinue }
// Оператор прерывания цикла: Прервать (выход из цикла)
BreakStmt { kwBreak }

// Оператор перехода: Перейти ~метка
GotoStmt { kwGoto "~" Identifier }
// Метка для оператора перехода: ~метка:
LabelStmt { "~" Identifier ":" }

// Оператор добавления обработчика события: ДобавитьОбработчик событие, обработчик
AddHandlerStmt { kwAddHandler Expression "," Expression }
// Оператор удаления обработчика события: УдалитьОбработчик событие, обработчик
RemoveHandlerStmt { kwRemoveHandler Expression "," Expression }

// Присваивание значения переменной: переменная = выражение
Assignment { !assign Identifier "=" Expression }

Expression[@isGroup=ExpressionGroup] {
  BaseExpr (BinaryOp BaseExpr)*
}

BaseExpr {
  (kwNot | "+" | "-") BaseExpr |
  Primary (CallArgs | MemberAccess | IndexAccess)* |
  "(" Expression ")"
}

BinaryOp {
  "*" | Divide | "%" | "+" | "-" | "=" | "<>" | ">=" | "<=" | ">" | "<" | kwAnd | kwOr
}

MemberAccess { "." Identifier }
IndexAccess { "[" Expression "]" }
CallArgs { "(" commaSep<Expression> ")" }

// Базовое выражение (Primary): простые выражения, не требующие дополнительного разбора
Primary {
  Literal |        // Литерал (число, строка, дата, булево значение и т.д.)
  Identifier |     // Идентификатор (переменная)
  NewExpr |        // Создание нового объекта
  TernaryExpr      // Тернарное выражение
}

// Создание нового объекта: Новый ТипОбъекта или Новый(конструктор, параметры)
NewExpr {
  kwNew Identifier |
  kwNew "(" Expression ("," Expression)? ")"
}

// Тернарное выражение: ?(условие, значение_если_истина, значение_если_ложь)
TernaryExpr { "?(" Expression "," Expression "," Expression ")" }

// Литерал: различные типы константных значений
Literal {
  Number |           // Числовой литерал
  String |           // Строковый литерал
  MultilineString |  // Многострочный строковый литерал
  Date |             // Литерал даты
  kwTrue |           // Булево значение Истина
  kwFalse |          // Булево значение Ложь
  kwUndefined |      // Значение Неопределено
  kwNull             // Значение Null
}

// --- Вспомогательные правила для ключевых слов (MVP: каноническое написание RU/EN) ---
// Ключевое слово Асинх/Async (асинхронная процедура/функция)
kwAsync { @specialize<Identifier, "Асинх"> | @specialize<Identifier, "Async"> }
// Ключевое слово Ждать/Await (ожидание асинхронной операции)
kwAwait { @specialize<Identifier, "Ждать"> | @specialize<Identifier, "Await"> }
// Ключевое слово Выполнить/Execute (выполнение строки кода)
kwExecute { @specialize<Identifier, "Выполнить"> | @specialize<Identifier, "Execute"> }

// Ключевое слово Процедура/Procedure
kwProcedure { @specialize<Identifier, "Процедура"> | @specialize<Identifier, "Procedure"> }
// Ключевое слово КонецПроцедуры/EndProcedure
kwEndProcedure { @specialize<Identifier, "КонецПроцедуры"> | @specialize<Identifier, "EndProcedure"> }
// Ключевое слово Функция/Function
kwFunction { @specialize<Identifier, "Функция"> | @specialize<Identifier, "Function"> }
// Ключевое слово КонецФункции/EndFunction
kwEndFunction { @specialize<Identifier, "КонецФункции"> | @specialize<Identifier, "EndFunction"> }
// Ключевое слово Экспорт/Export (экспорт процедуры/функции)
kwExport { @specialize<Identifier, "Экспорт"> | @specialize<Identifier, "Export"> }
// Ключевое слово Знач/Val (передача параметра по значению)
kwVal { @specialize<Identifier, "Знач"> | @specialize<Identifier, "Val"> }
// Ключевое слово Перем/Var (объявление переменной)
kwVar { @specialize<Identifier, "Перем"> | @specialize<Identifier, "Var"> }
// Ключевое слово Возврат/Return (возврат из процедуры/функции)
kwReturn { @specialize<Identifier, "Возврат"> | @specialize<Identifier, "Return"> }

// Ключевые слова условного оператора: Если/If, Тогда/Then, ИначеЕсли/ElsIf, Иначе/Else, КонецЕсли/EndIf
kwIf { @specialize<Identifier, "Если"> | @specialize<Identifier, "If"> }
kwThen { @specialize<Identifier, "Тогда"> | @specialize<Identifier, "Then"> }
kwElseIf { @specialize<Identifier, "ИначеЕсли"> | @specialize<Identifier, "ElsIf"> }
kwElse { @specialize<Identifier, "Иначе"> | @specialize<Identifier, "Else"> }
kwEndIf { @specialize<Identifier, "КонецЕсли"> | @specialize<Identifier, "EndIf"> }

// Ключевые слова циклов:
// Пока/While (цикл с условием), Для/For (цикл для), Каждого/Each (для каждого элемента),
// Из/In (из коллекции), По/To (до значения), Цикл/Do (начало тела цикла), КонецЦикла/EndDo
kwWhile { @specialize<Identifier, "Пока"> | @specialize<Identifier, "While"> }
kwFor { @specialize<Identifier, "Для"> | @specialize<Identifier, "For"> }
kwEach { @specialize<Identifier, "Каждого"> | @specialize<Identifier, "Each"> }
kwIn { @specialize<Identifier, "Из"> | @specialize<Identifier, "In"> }
kwTo { @specialize<Identifier, "По"> | @specialize<Identifier, "To"> }
kwDo { @specialize<Identifier, "Цикл"> | @specialize<Identifier, "Do"> }
kwEndDo { @specialize<Identifier, "КонецЦикла"> | @specialize<Identifier, "EndDo"> }

// Ключевые слова обработки исключений:
// Попытка/Try (начало блока обработки), Исключение/Except (обработчик исключения),
// КонецПопытки/EndTry (конец блока), ВызватьИсключение/Raise (выброс исключения)
kwTry { @specialize<Identifier, "Попытка"> | @specialize<Identifier, "Try"> }
kwExcept { @specialize<Identifier, "Исключение"> | @specialize<Identifier, "Except"> }
kwEndTry { @specialize<Identifier, "КонецПопытки"> | @specialize<Identifier, "EndTry"> }
kwRaise { @specialize<Identifier, "ВызватьИсключение"> | @specialize<Identifier, "Raise"> }

// Ключевые слова управления потоком выполнения:
// Перейти/Goto (переход к метке), Прервать/Break (выход из цикла), Продолжить/Continue (следующая итерация)
kwGoto { @specialize<Identifier, "Перейти"> | @specialize<Identifier, "Goto"> }
kwBreak { @specialize<Identifier, "Прервать"> | @specialize<Identifier, "Break"> }
kwContinue { @specialize<Identifier, "Продолжить"> | @specialize<Identifier, "Continue"> }

// Ключевые слова работы с обработчиками событий:
// ДобавитьОбработчик/AddHandler (добавление), УдалитьОбработчик/RemoveHandler (удаление)
kwAddHandler { @specialize<Identifier, "ДобавитьОбработчик"> | @specialize<Identifier, "AddHandler"> }
kwRemoveHandler { @specialize<Identifier, "УдалитьОбработчик"> | @specialize<Identifier, "RemoveHandler"> }

// Ключевые слова логических операций: НЕ/NOT, И/AND, ИЛИ/OR
kwNot { @specialize<Identifier, "НЕ"> | @specialize<Identifier, "NOT"> }
kwAnd { @specialize<Identifier, "И"> | @specialize<Identifier, "AND"> }
kwOr { @specialize<Identifier, "ИЛИ"> | @specialize<Identifier, "OR"> }
// Ключевое слово Новый/New (создание объекта)
kwNew { @specialize<Identifier, "Новый"> | @specialize<Identifier, "New"> }

// Литералы булевых и специальных значений:
// Истина/True (булево истина), Ложь/False (булево ложь),
// Неопределено/Undefined (неопределенное значение), Null (пустое значение)
kwTrue { @specialize<Identifier, "Истина"> | @specialize<Identifier, "True"> }
kwFalse { @specialize<Identifier, "Ложь"> | @specialize<Identifier, "False"> }
kwUndefined { @specialize<Identifier, "Неопределено"> | @specialize<Identifier, "Undefined"> }
kwNull { @specialize<Identifier, "Null"> }

@detectDelim

