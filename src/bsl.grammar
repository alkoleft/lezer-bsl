@precedence {
  typeargs,
  typeMember,
  typePrefix,
  intersectionPrefixed @left,
  intersection @left,
  unionPrefixed @left,
  union @left,
  typeExtends @right,
  else @right,
  member,
  readonly,
  newArgs,
  call,
  instantiate,
  taggedTemplate,
  prefix,
  postfix,
  typeof,
  exp @left,
  times @left,
  plus @left,
  shift @left,
  loop,
  rel @left,
  satisfies,
  equal @left,
  bitAnd @left,
  bitXor @left,
  bitOr @left,
  and @left,
  or @left,
  ternary @right,
  assign @right,
  comma @left,
  statement @cut,
  predicate
}

// Корневой элемент модуля - последовательность элементов (процедур, функций, операторов)
@top Module { element* }

// Пропускаемые символы при парсинге (пробелы и однострочные комментарии)
@skip { space | LineComment }

// Определение токенов (лексических единиц)
@tokens {
  // Пробельные символы (пробелы, табы и т.д.)
  space { @whitespace+ }
  
  // Однострочный комментарий, начинается с // и продолжается до конца строки
  LineComment[isolate] {
    "//" ![\n]*
  }

  // Оператор деления (отдельный токен для корректной обработки приоритетов)
  divide[@name=ArithOp] { "/" }

  // Строка препроцессора (директива компиляции, начинается с #)
  // Сохраняется как токен для возможности анализа потребителями
  Preproc { "#" ![\n]* }

  // Строка аннотации (директивы компилятора / метаданные обработчиков и т.д.)
  // Сохраняется как токен для избежания LR конфликтов при парсинге
  Annotation { "&" ![\n]* }

  // Числовой литерал (целое число или число с плавающей точкой)
  Number {
    @digit+ ("." @digit+)?
  }

  // Строковый литерал: в BSL используются двойные кавычки, экранирование через удвоение ("")
  // Закрывающая кавычка сделана опциональной для поддержки незавершенных строк
  String[isolate] { "\"" (stringContent | "\"\"")* "\""? }
  
  // Многострочная строка в BSL:
  // "строка1
  // |строка2
  // |строка3"
  MultilineString[isolate] {
    "\"" (stringContent | "\"\"")*
    (("\r"? "\n") $[ \t]* "|" (stringContent | "\"\"")*)+
    "\""?
  }

  // Содержимое строки (любые символы кроме кавычек, обратного слэша и переводов строк)
  stringContent { !["\\\n]+ }

  // Литерал даты: 'YYYYMMDD' или 'YYYYMMDDhhmmss' в одинарных кавычках
  Date { "'" @digit@digit@digit@digit@digit@digit@digit@digit (@digit@digit@digit@digit@digit@digit)? "'" }

  // Идентификатор: начинается с буквы или подчеркивания, может содержать буквы, цифры, кириллицу
  identifier { IdentStart IdentContinue* }
  // Первый символ идентификатора: латинская буква, подчеркивание или кириллица
  IdentStart { @asciiLetter | $[_А-Яа-яЁё] }
  // Последующие символы идентификатора: то же самое плюс цифры
  IdentContinue { IdentStart | @digit }

  // Приоритеты токенов для разрешения неоднозначностей
  @precedence { LineComment, divide }
  @precedence { MultilineString, String }
  @precedence { space, identifier }
}

// Элемент модуля: может быть строка препроцессора, аннотация, определение метода или оператор
element {
  PreprocLine |
  ProcedureDef |
  FunctionDef |
  statement
}

// Строка препроцессора
PreprocLine { Preproc }

// Вспомогательное правило: разделенный запятыми список элементов (может быть пустым)
commaSep<content> {
  "" | content ("," content?)*
}

// Вспомогательное правило: разделенный запятыми список элементов (минимум один элемент)
commaSep1<content> {
  content ("," content)*
}

// Объявление переменных модуля: ключевое слово Перем, список спецификаций переменных, точка с запятой
VarDecl {
  Annotation?
  kw<"Var", "Перем">
  commaSep1<VariableName>
  namedKw<"Export", "Экспорт">?
}

// Определение процедуры: опционально асинхронная, ключевое слово Процедура, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецПроцедуры
ProcedureDef {
  Annotation?
  namedKw<"Async", "Асинх">?
  kw<"Procedure", "Процедура">
  Name { identifier }
  ParamList
  namedKw<"Export", "Экспорт">?
  Block
  kw<"EndProcedure", "КонецПроцедуры">
}

// Определение функции: опционально асинхронная, ключевое слово Функция, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецФункции
FunctionDef {
  Annotation?
  namedKw<"Async", "Асинх">?
  kw<"Function", "Функция">
  Name { identifier }
  ParamList
  namedKw<"Export", "Экспорт">?
  Block
  kw<"EndFunction", "КонецФункции">
}

// Список параметров: в круглых скобках, разделенные запятыми
ParamList { "(" commaSep<Param> ")" }

// Параметр: опционально ключевое слово Знач (передача по значению), затем имя
Param {
  namedKw<"Val", "Знач">?
  Name { identifier }
  DefaultValue { "=" literal }?
}

// Блок кода: последовательность операторов, строк препроцессора и аннотаций
Block {
  (statement | PreprocLine)*
}

// Оператор (statement): различные типы операторов языка
// Помечен как группа для удобства работы с AST
statement[@isGroup=Statement] {
  IfStmt ";" |                   // Условный оператор
  WhileStmt ";" |                // Цикл пока
  ForStmt ";" |                  // Цикл для
  ForEachStmt ";" |              // Цикл для каждого
  TryStmt ";" |                  // Блок обработки исключений
  ExecuteStmt ";" |              // Оператор Выполнить
  AwaitStmt { AwaitExpr } ";" |  // Оператор Ждать
  ContinueStmt ";" |             // Оператор Продолжить
  BreakStmt ";" |                // Оператор Прервать
  GotoStmt ";" |                 // Оператор Перейти
  LabelStmt ";" |                // Метка (для оператора Перейти)
  AddHandlerStmt ";" |           // Оператор ДобавитьОбработчик
  RemoveHandlerStmt ";" |        // Оператор УдалитьОбработчик
  ReturnStmt ";" |               // Оператор Возврат
  RaiseStmt ";" |                // Оператор ВызватьИсключение
  VarDecl ";" |                  // Объявление переменных
  AssignmentStmt ";" |           // Присваивание
  CallStmt ";" |                 // Вызов метода
  ";"                            // Пустой оператор
}

// Оператор вызова метода: переменная или свойство объекта с аргументами
CallStmt {
  !assign
  VariableName
  (memberAccess | indexAccess)*
  ArgList
}

// Условный оператор: Если ... Тогда ... ИначеЕсли ... Тогда ... Иначе ... КонецЕсли
IfStmt {
  kw<"If", "Если">
  Condition { expression }
  kw<"Then", "Тогда">
  Block
  ElseIfClause {
    kw<"ElseIf", "ИначеЕсли">
    Condition { expression }
    kw<"Then", "Тогда">
    Block
  }*
  ElseClause {
    kw<"Else", "Иначе">
    Block
  }?
  kw<"EndIf", "КонецЕсли">
}

// Цикл пока: Пока ... Цикл ... КонецЦикла
WhileStmt {
  kw<"While", "Пока">
  Condition { expression }
  kw<"Do", "Цикл">
  Block
  kw<"EndDo", "КонецЦикла">
}

// Цикл для: может быть двух видов:
// 1. Для Каждого ... Из ... (перебор коллекции)
// 2. Для ... = ... По ... (цикл с счетчиком)
ForEachStmt {
  kw<"For", "Для">
  kw<"Each", "Каждого">
  VariableName
  kw<"In", "Из">
  Collection { expression }
  kw<"Do", "Цикл">
  Block
  kw<"EndDo", "КонецЦикла">
}
ForStmt {
  kw<"For", "Для">
  VariableName
  "="
  Start { expression }
  kw<"To", "По">
  End { expression }
  kw<"Do", "Цикл">
  Block
  kw<"EndDo", "КонецЦикла">
}

// Блок обработки исключений: Попытка ... Исключение ... КонецПопытки
TryStmt {
  kw<"Try", "Попытка">
  Block
  kw<"Except", "Исключение">
  Block
  kw<"EndTry", "КонецПопытки">
}

// Оператор возврата из функции/процедуры: Возврат [значение]
ReturnStmt {
  kw<"Return", "Возврат">
  Expression { expression }?
}

// Оператор вызова исключения: ВызватьИсключение [значение]
RaiseStmt {
  kw<"Raise", "ВызватьИсключение">
  Expression { expression }?
}

// Оператор выполнения выражения: Выполнить выражение
ExecuteStmt {
  kw<"Execute", "Выполнить">
  Expression { expression }
}

// Оператор продолжения цикла: Продолжить (переход к следующей итерации)
ContinueStmt {
  kw<"Continue", "Continue">
}

// Оператор прерывания цикла: Прервать (выход из цикла)
BreakStmt {
  kw<"Break", "Прервать">
}

// Оператор перехода: Перейти ~метка
GotoStmt {
  kw<"Goto", "Перейти">
  "~"
  LabelName { identifier }
}

// Метка для оператора перехода: ~метка:
LabelStmt {
  "~"
  LabelName { identifier }
  ":"
}

// Оператор добавления обработчика события: ДобавитьОбработчик событие, обработчик
AddHandlerStmt {
  kw<"AddHandler", "ДобавитьОбработчик">
  Event { expression }
  ","
  Handler { expression }
}

// Оператор удаления обработчика события: УдалитьОбработчик событие, обработчик
RemoveHandlerStmt {
  kw<"RemoveHandler", "УдалитьОбработчик">
  Event { expression }
  ","
  Handler { expression }
}

// Присваивание значения переменной: переменная = выражение
// Поддерживает присваивание простым переменным, свойствам объектов и элементам массивов
// Разворачивается напрямую: VariableName с опциональными memberAccess и indexAccess
AssignmentStmt {
  !assign
  VariableName
  (memberAccess | indexAccess)*
  "="
  Expression { expression }
}

// Выражение: различные типы выражений языка
expression {
  literal |                        // Литерал (число, строка, дата, булево значение и т.д.)
  VariableName |                   // Идентификатор (переменная)
  NewExpr |                        // Создание нового объекта
  TernaryExpr |                    // Тернарное выражение
  ParenthesizedExpr |              // Выражение в скобках
  CallExpr |                       // Вызов функции/метода
  BinaryExpr |                     // Бинарное выражение (операции с двумя операндами)
  MemberExpr |                     // Доступ к свойству или элементу массива
  AwaitExpr |                      // Асинхронное выражение
  UnaryExpr                        // Унарное выражение
}

// Вызов функции/метода: выражение со списком аргументов
CallExpr {
  expression !call ArgList
}

// Бинарное выражение: операции с двумя операндами
BinaryExpr {
  expression !times (divide | ArithOp<"%"> | ArithOp<"*">) expression |
  expression !plus (ArithOp<"+"> | ArithOp<"-">) expression |
  expression !rel (CompareOp<">=" | "<=" | ">" | "<">) expression |
  expression !equal CompareOp<"=" | "<>"> expression |
  expression !and LogicOp<namedKw<"AND", "И">> expression |
  expression !or LogicOp<namedKw<"OR", "ИЛИ">> expression
}

// Асинхронное выражение: Ждать выражение
AwaitExpr {
  !prefix kw<"Await", "Ждать"> expression
}

// Унарное выражение: НЕ выражение или отрицание числа
UnaryExpr {
  !prefix (namedKw<"NOT", "НЕ"> | ArithOp<"-">) expression
}

// Выражение в скобках: (выражение)
ParenthesizedExpr {
  "(" expression ")"
}

// Доступ к свойству объекта или элементу массива: выражение.свойство или выражение[индекс]
MemberExpr {
  expression !member (memberAccess | indexAccess)
}

// Имя переменной: идентификатор
VariableName { identifier }

// Доступ к свойству объекта: .свойство
memberAccess { "." PropertyName { identifier } }

// Доступ к элементу массива: [индекс]
indexAccess { "[" Index { expression } "]" }

// Список аргументов: разделенные запятыми выражения в скобках
ArgList { "(" commaSep<expression> ")" }

// Создание нового объекта: Новый ТипОбъекта или Новый(конструктор, параметры)
NewExpr {
  kw<"New", "Новый">
  TypeName { identifier } |
  kw<"New", "Новый">
  "("
  commaSep1<expression>
  ")"
}

// Тернарное выражение: ?(условие, значение_если_истина, значение_если_ложь)
TernaryExpr {
  "?("
  Condition { expression }
  ","
  TrueCause { expression }
  ","
  FalseCause { expression }
  ")"
}

// Литерал: различные типы константных значений
literal {
  Number |                                    // Числовой литерал
  String |                                    // Строковый литерал
  MultilineString |                           // Многострочный строковый литерал
  Date |                                      // Литерал даты
  namedKw<"True", "Истина"> |                 // Булево значение Истина
  namedKw<"False", "Ложь"> |                  // Булево значение Ложь
  namedKw<"Undefined", "Неопределено"> |      // Значение Неопределено
  @specialize[@name=Null]<identifier, "Null"> // Значение Null
}

// --- Вспомогательные правила для ключевых слов (MVP: каноническое написание RU/EN) ---

// Общее правило для ключевых слов: поддерживает русский и английский варианты
kw<termEn, termRu> {
  @specialize<identifier, termRu> |
  @specialize<identifier, termEn>
}

// Именованное ключевое слово: аналогично kw, но с явным именем в AST
namedKw<termEn, termRu> {
  @specialize[@name={termEn}]<identifier, termRu> |
  @specialize[@name={termEn}]<identifier, termEn>
}

// Арифметический оператор: базовое правило для арифметических операций
ArithOp<expr> { expr }

// Логический оператор: базовое правило для логических операций
LogicOp<expr> { expr }

// Оператор сравнения: базовое правило для операций сравнения
CompareOp<expr> { expr }

@detectDelim

