@precedence {
  else @right,
  member,
  newExpr,
  call,
  prefix,
  postfix,
  exp @left,
  times @left,
  plus @left,
  loop,
  rel @left,
  equal @left,
  and @left,
  or @left,
  ternary @right,
  assign @right,
  comma @left,
  statement @cut
}

// Корневой элемент модуля - последовательность элементов (процедур, функций, операторов)
// Последний оператор может быть без `;`.
@top Module { 
  (VarDecl ";")* 
  (ProcedureDef | FunctionDef)*
  ModuleBlock?
  }

// Пропускаемые символы при парсинге (пробелы и однострочные комментарии)
@skip { space | LineComment | Preproc }

// Определение токенов (лексических единиц)
@tokens {
  // Пробельные символы (пробелы, табы и т.д.)
  space { @whitespace+ }
  
  // Однострочный комментарий, начинается с // и продолжается до конца строки
  LineComment[isolate] {
    "//" ![\n]*
  }

  // Оператор деления (отдельный токен для корректной обработки приоритетов)
  divide[@name=ArithOp] { "/" }

  // Строка препроцессора (директива компиляции, начинается с #)
  // Сохраняется как токен для возможности анализа потребителями
  Preproc { "#" ![\n]* }

  // Числовой литерал (целое число или число с плавающей точкой)
  Number {
    @digit+ ("." @digit+)?
  }

  // Строковый литерал: в BSL используются двойные кавычки, экранирование через удвоение ("")
  // Закрывающая кавычка сделана опциональной для поддержки незавершенных строк
  String[isolate] { "\"" (stringContent | "\"\"")* "\""? }
  
  // Многострочная строка в BSL:
  // "строка1
  // |строка2
  // |строка3"
  MultilineString[isolate] {
    "\"" (stringContent | "\"\"")*
    (("\r"? "\n") $[ \t]* "|" (stringContent | "\"\"")*)+
    "\""?
  }

  // Содержимое строки (любые символы кроме кавычек, обратного слэша и переводов строк)
  stringContent { !["\\\n]+ }

  // Литерал даты: 'YYYYMMDD' или 'YYYYMMDDhhmmss' в одинарных кавычках
  // Поддерживает разделители: '2017.03.23 10:45:25', '2017\03\23-10~45~25'
  Date { "'" dateContent "'" }
  dateContent { (@digit+ (!['0-9] @digit+)*)+ }

  // Идентификатор: начинается с буквы или подчеркивания, может содержать буквы, цифры, кириллицу
  identifier { IdentStart IdentContinue* }
  // Первый символ идентификатора: латинская буква, подчеркивание или кириллица
  IdentStart { @asciiLetter | $[_А-Яа-яЁё] }
  // Последующие символы идентификатора: то же самое плюс цифры
  IdentContinue { IdentStart | @digit }

  // Приоритеты токенов для разрешения неоднозначностей
  @precedence { LineComment, divide }
  @precedence { MultilineString, String }
  @precedence { space, identifier }
}

ModuleBlock {
  ";"* blockItem
  (";" blockItem?)*
}

// Объявление переменных модуля: ключевое слово Перем, список спецификаций переменных, точка с запятой
VarDecl {
  Annotation?
  kw<"Var", "Перем">
  commaSep1<VarSpec>
}

// Спецификация переменной: имя переменной с опциональным модификатором Экспорт
VarSpec {
  VariableName
  namedKw<"Export", "Экспорт">?
}

// Аннотация компиляции: директивы для процедур и функций
Annotation {
  "&" AnnotationType ("(" String ")")?
}

AnnotationType {
  kw<"AtClient", "НаКлиенте"> |
  kw<"AtServer", "НаСервере"> |
  kw<"AtServerNoContext", "НаСервереБезКонтекста"> |
  kw<"AtClientAtServerNoContext", "НаКлиентеНаСервереБезКонтекста"> |
  kw<"AtClientAtServer", "НаКлиентеНаСервере"> |
  kw<"Before", "Перед"> |
  kw<"After", "После"> |
  kw<"Around", "Вместо"> |
  kw<"ChangeAndValidate", "ИзменениеИКонтроль">
}

// Определение процедуры: опционально асинхронная, ключевое слово Процедура, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецПроцедуры
ProcedureDef {
  Annotation*
  namedKw<"Async", "Асинх">?
  kw<"Procedure", "Процедура">
  Name { identifier }
  ParamList
  namedKw<"Export", "Экспорт">?
  (VarDecl ";")*
  Block?
  kw<"EndProcedure", "КонецПроцедуры">
}

// Определение функции: опционально асинхронная, ключевое слово Функция, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецФункции
FunctionDef {
  Annotation*
  namedKw<"Async", "Асинх">?
  kw<"Function", "Функция">
  Name { identifier }
  ParamList
  namedKw<"Export", "Экспорт">?
  (VarDecl ";")*
  Block?
  kw<"EndFunction", "КонецФункции">
}

// Список параметров: в круглых скобках, разделенные запятыми
ParamList { "(" commaSep<Param> ")" }

// Параметр: опционально ключевое слово Знач (передача по значению), затем имя и значение по умолчанию
Param {
  namedKw<"Val", "Знач">?
  Name { identifier }
  DefaultValue { "=" literal }?
}

// Блок кода: последовательность операторов, строк препроцессора и аннотаций
// Блок кода: объявления переменных в начале, затем операторы
Block {
  ";"* blockItem
  (";" blockItem?)*
}

// Элемент блока: метка и/или оператор
blockItem {
  LabelStmt statement? |
  statement
}

// Оператор (без `;`): различные типы операторов языка (кроме метки)
// Помечен как группа для удобства работы с AST
statement[@isGroup=Statement] {
  IfStmt |                   // Условный оператор
  WhileStmt |                // Цикл пока
  ForStmt |                  // Цикл для
  ForEachStmt |              // Цикл для каждого
  TryStmt |                  // Блок обработки исключений
  AwaitStmt { AwaitExpr } |  // Оператор Ждать
  ContinueStmt |             // Оператор Продолжить
  BreakStmt |                // Оператор Прервать
  GotoStmt |                 // Оператор Перейти
  AddHandlerStmt |           // Оператор ДобавитьОбработчик
  RemoveHandlerStmt |        // Оператор УдалитьОбработчик
  ReturnStmt |               // Оператор Возврат
  RaiseStmt |                // Оператор ВызватьИсключение
  AssignmentStmt |           // Присваивание
  CallStmt |                 // Вызов метода (проверяется перед ExecuteStmt, чтобы избежать конфликта с Объект.Выполнить())
  ExecuteStmt                // Оператор Выполнить
}

// Оператор вызова метода: переменная или свойство объекта с аргументами
// Поддерживает цепочки вызовов: Объект.Метод1().Метод2()
CallStmt {
  !assign
  VariableName
  // Базовая цепочка доступа (свойства/индексы)
  (memberAccess | indexAccess)*
  // Вызовы методов в цепочке:
  //   Объект.Метод1().Метод2()
  // Представляем как ArgList + продолжение цепочки доступа, повторяемое несколько раз.
  (ArgList (memberAccess | indexAccess)*)*
  // Финальный вызов метода
  ArgList
}

// Условный оператор: Если ... Тогда ... ИначеЕсли ... Тогда ... Иначе ... КонецЕсли
IfStmt {
  kw<"If", "Если">
  Condition { expression }
  kw<"Then", "Тогда">
  Block?
  ElseIfClause {
    kw<"ElseIf", "ИначеЕсли">
    Condition { expression }
    kw<"Then", "Тогда">
    Block?
  }*
  ElseClause {
    kw<"Else", "Иначе">
    Block?
  }?
  kw<"EndIf", "КонецЕсли">
}

// Цикл пока: Пока ... Цикл ... КонецЦикла
WhileStmt {
  kw<"While", "Пока">
  Condition { expression }
  kw<"Do", "Цикл">
  Block?
  kw<"EndDo", "КонецЦикла">
}

// Цикл для: может быть двух видов:
// 1. Для Каждого ... Из ... (перебор коллекции)
// 2. Для ... = ... По ... (цикл с счетчиком)
ForEachStmt {
  kw<"For", "Для">
  kw<"Each", "Каждого">
  VariableName
  kw<"In", "Из">
  Collection { expression }
  kw<"Do", "Цикл">
  Block?
  kw<"EndDo", "КонецЦикла">
}
ForStmt {
  kw<"For", "Для">
  VariableName
  "="
  Start { expression }
  kw<"To", "По">
  End { expression }
  kw<"Do", "Цикл">
  Block?
  kw<"EndDo", "КонецЦикла">
}

// Блок обработки исключений: Попытка ... Исключение ... КонецПопытки
TryStmt {
  kw<"Try", "Попытка">
  Block?
  kw<"Except", "Исключение">
  Block?
  kw<"EndTry", "КонецПопытки">
}

// Оператор возврата из функции/процедуры: Возврат [значение]
ReturnStmt {
  kw<"Return", "Возврат">
  Expression { expression }?
}

// Оператор вызова исключения: ВызватьИсключение [значение] или ВызватьИсключение(параметры)
// Форма со скобками требует минимум 2 параметра для различения от ParenthesizedExpr
RaiseStmt {
  kw<"Raise", "ВызватьИсключение"> (
    "(" expression "," commaSep<expression> ")" |
    Expression { expression }
  )?
}

// Оператор выполнения выражения: Выполнить выражение
// Не распознается после точки (чтобы не конфликтовать с CallStmt: Объект.Выполнить())
ExecuteStmt {
  !member
  kw<"Execute", "Выполнить">
  Expression { expression }
}

// Оператор продолжения цикла: Продолжить (переход к следующей итерации)
ContinueStmt {
  kw<"Continue", "Продолжить">
}

// Оператор прерывания цикла: Прервать (выход из цикла)
BreakStmt {
  kw<"Break", "Прервать">
}

// Оператор перехода: Перейти ~метка
GotoStmt {
  kw<"Goto", "Перейти">
  "~"
  LabelName { identifier }
}

// Метка для оператора перехода: ~метка:
LabelStmt {
  "~"
  LabelName { identifier }
  ":"
}

// Оператор добавления обработчика события: ДобавитьОбработчик событие, обработчик
AddHandlerStmt {
  kw<"AddHandler", "ДобавитьОбработчик">
  Event { expression }
  ","
  Handler { expression }
}

// Оператор удаления обработчика события: УдалитьОбработчик событие, обработчик
RemoveHandlerStmt {
  kw<"RemoveHandler", "УдалитьОбработчик">
  Event { expression }
  ","
  Handler { expression }
}

// Присваивание значения переменной: переменная = выражение
// Поддерживает присваивание простым переменным, свойствам объектов и элементам массивов
// Разворачивается напрямую: VariableName с опциональными memberAccess и indexAccess
AssignmentStmt {
  !assign
  VariableName
  // Базовая цепочка доступа (свойства/индексы)
  (memberAccess | indexAccess)*
  // Вызовы методов в левой части присваивания:
  //   Объект.Метод1().Метод2().Свойство = ...
  // Представляем как ArgList + продолжение цепочки доступа, повторяемое несколько раз.
  (ArgList (memberAccess | indexAccess)*)*
  "="
  Expression { expression }
}

// Выражение: различные типы выражений языка
expression {
  literal |                        // Литерал (число, строка, дата, булево значение и т.д.)
  VariableName |                   // Идентификатор (переменная)
  NewExpr |                        // Создание нового объекта
  TernaryExpr |                    // Тернарное выражение
  ParenthesizedExpr |              // Выражение в скобках
  CallExpr |                       // Вызов функции/метода
  BinaryExpr |                     // Бинарное выражение (операции с двумя операндами)
  MemberExpr |                     // Доступ к свойству или элементу массива
  AwaitExpr |                      // Асинхронное выражение
  UnaryExpr                        // Унарное выражение
}

// Вызов функции/метода: выражение со списком аргументов
CallExpr {
  expression !call ArgList
}

// Бинарное выражение: операции с двумя операндами
BinaryExpr {
  expression !times (divide | ArithOp<"%"> | ArithOp<"*">) expression |
  expression !plus (ArithOp<"+"> | ArithOp<"-">) expression |
  expression !rel (CompareOp<">=" | "<=" | ">" | "<">) expression |
  expression !equal CompareOp<"=" | "<>"> expression |
  expression !and LogicOp<namedKw<"AND", "И">> expression |
  expression !or LogicOp<namedKw<"OR", "ИЛИ">> expression
}

// Асинхронное выражение: Ждать выражение
AwaitExpr {
  !prefix kw<"Await", "Ждать"> expression
}

// Унарное выражение: НЕ выражение или отрицание числа
UnaryExpr {
  !prefix (namedKw<"NOT", "НЕ"> | ArithOp<"-">) expression
}

// Выражение в скобках: (выражение)
ParenthesizedExpr {
  "(" expression ")"
}

// Доступ к свойству объекта или элементу массива: выражение.свойство или выражение[индекс]
MemberExpr {
  expression !member (memberAccess | indexAccess)
}

// Имя переменной: идентификатор
VariableName { identifier }

// Доступ к свойству объекта: .свойство
memberAccess { "." PropertyName { identifier } }

// Доступ к элементу массива или свойству по строке: [индекс] или ["свойство"]
indexAccess { "[" Index { expression } "]" }

// Список аргументов: разделенные запятыми выражения в скобках
ArgList { "(" commaSep<expression> ")" }

// Создание нового объекта: Новый Тип, Новый Тип(параметры) или Новый(конструктор, параметры)
NewExpr {
  kw<"New", "Новый"> !newExpr TypeName { identifier } ArgList? |
  kw<"New", "Новый"> "(" commaSep1<expression> ")"
}

// Тернарное выражение: ?(условие, значение_если_истина, значение_если_ложь)
TernaryExpr {
  "?("
  Condition { expression }
  ","
  TrueCause { expression }
  ","
  FalseCause { expression }
  ")"
}

// Литерал: различные типы константных значений
literal {
  Number |                                    // Числовой литерал
  String |                                    // Строковый литерал
  MultilineString |                           // Многострочный строковый литерал
  Date |                                      // Литерал даты
  namedKw<"True", "Истина"> |                 // Булево значение Истина
  namedKw<"False", "Ложь"> |                  // Булево значение Ложь
  namedKw<"Undefined", "Неопределено"> |      // Значение Неопределено
  @specialize[@name=Null]<identifier, "Null"> // Значение Null
}

// --- Вспомогательные правила для ключевых слов (MVP: каноническое написание RU/EN) ---

// Общее правило для ключевых слов: поддерживает русский и английский варианты
kw<termEn, termRu> {
  @specialize<identifier, termRu> |
  @specialize<identifier, termEn>
}

// Именованное ключевое слово: аналогично kw, но с явным именем в AST
namedKw<termEn, termRu> {
  @specialize[@name={termEn}]<identifier, termRu> |
  @specialize[@name={termEn}]<identifier, termEn>
}

// Арифметический оператор: базовое правило для арифметических операций
ArithOp<expr> { expr }

// Логический оператор: базовое правило для логических операций
LogicOp<expr> { expr }

// Оператор сравнения: базовое правило для операций сравнения
CompareOp<expr> { expr }

// Вспомогательное правило: разделенный запятыми список элементов (может быть пустым)
commaSep<content> {
  "" | content ("," content?)*
}

// Вспомогательное правило: разделенный запятыми список элементов (минимум один элемент)
commaSep1<content> {
  content ("," content)*
}

@detectDelim

