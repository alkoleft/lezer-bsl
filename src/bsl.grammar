@precedence {
  else @right,
  member,
  newExpr,
  call,
  prefix,
  postfix,
  exp @left,
  times @left,
  plus @left,
  loop,
  rel @left,
  equal @left,
  and @left,
  or @left,
  ternary @right,
  assign @right,
  comma @left,
  statement @cut
}

// Корневой элемент модуля - последовательность элементов (процедур, функций, операторов)
// Последний оператор может быть без `;`.
@top Module { 
  (VarDecl ";")* 
  (ProcedureDef | FunctionDef)*
  ModuleBlock?
  }

// Пропускаемые символы при парсинге (пробелы и однострочные комментарии)
@skip { space | Comment | Preproc }

// Определение токенов (лексических единиц)
@tokens {
  // Пробельные символы (пробелы, табы и т.д.)
  space { @whitespace+ }
  
  // Однострочный комментарий, начинается с // и продолжается до конца строки
  Comment {
    "//" ![\n]*
  }

  // Оператор деления (отдельный токен для корректной обработки приоритетов)
  divide[@name=ArithOp] { "/" }

  // Строка препроцессора (директива компиляции, начинается с #)
  // Сохраняется как токен для возможности анализа потребителями
  Preproc { "#" ![\n]* }

  // Числовой литерал (целое число или число с плавающей точкой)
  Number {
    @digit+ ("." @digit+)?
  }

  // Литерал даты: 'YYYYMMDD' или 'YYYYMMDDhhmmss' в одинарных кавычках
  // Поддерживает разделители: '2017.03.23 10:45:25', '2017\03\23-10~45~25'
  Date { "'" dateContent "'" }
  dateContent { (@digit+ (!['0-9] @digit+)*)+ }

  // Идентификатор: начинается с буквы или подчеркивания, может содержать буквы, цифры, кириллицу
  identifier { IdentStart IdentContinue* }
  // Первый символ идентификатора: латинская буква, подчеркивание или кириллица
  IdentStart { @asciiLetter | $[_А-Яа-яЁё] }
  // Последующие символы идентификатора: то же самое плюс цифры
  IdentContinue { IdentStart | @digit }

  // Приоритеты токенов для разрешения неоднозначностей
  @precedence { Comment, divide }
  @precedence { space, identifier }

  // Токены для строк обрабатываются external tokenizer
}

@external tokens stringTokens from "./stringTokenizer.js" {
  String
  MultilineStringStart
  MultilineStringContinue
}

MultilineString[@dynamicPrecedence=1] {
  MultilineStringStart MultilineStringContinue * |
  String String+
}

ModuleBlock {
  ";"* blockItem
  (";" blockItem?)*
}

// Объявление переменных модуля: ключевое слово Перем, список спецификаций переменных, точка с запятой
VarDecl {
  Annotation?
  namedKw<"var", "Перем">
  commaSep1<VarSpec>
}

// Спецификация переменной: имя переменной с опциональным модификатором Экспорт
VarSpec {
  VariableName
  namedKw<"export", "Экспорт">?
}

// Аннотация компиляции: директивы для процедур и функций
Annotation {
  "&" AnnotationType ("(" String ")")?
}

AnnotationType { identifier }

// Определение процедуры: опционально асинхронная, ключевое слово Процедура, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецПроцедуры
ProcedureDef {
  Annotation*
  namedKw<"async", "Асинх">?
  namedKw<"procedure", "Процедура">
  Name { identifier }
  ParamList
  namedKw<"export", "Экспорт">?
  (VarDecl ";")*
  Block?
  namedKw<"endProcedure", "КонецПроцедуры">
}

// Определение функции: опционально асинхронная, ключевое слово Функция, имя, список параметров,
// опциональный модификатор Экспорт, блок кода, ключевое слово КонецФункции
FunctionDef {
  Annotation*
  namedKw<"async", "Асинх">?
  namedKw<"function", "Функция">
  Name { identifier }
  ParamList
  namedKw<"export", "Экспорт">?
  (VarDecl ";")*
  Block?
  namedKw<"endFunction", "КонецФункции">
}

// Список параметров: в круглых скобках, разделенные запятыми
ParamList { "(" commaSep<Param> ")" }

// Параметр: опционально ключевое слово Знач (передача по значению), затем имя и значение по умолчанию
Param {
  namedKw<"val", "Знач">?
  Name { identifier }
  DefaultValue { "=" literal }?
}

// Блок кода: последовательность операторов, строк препроцессора и аннотаций
// Блок кода: объявления переменных в начале, затем операторы
Block {
  ";"* blockItem
  (";" blockItem?)*
}

// Элемент блока: метка и/или оператор
blockItem {
  LabelStmt statement? |
  statement
}

// Оператор (без `;`): различные типы операторов языка (кроме метки)
// Помечен как группа для удобства работы с AST
statement[@isGroup=Statement] {
  IfStmt |                   // Условный оператор
  WhileStmt |                // Цикл пока
  ForStmt |                  // Цикл для
  ForEachStmt |              // Цикл для каждого
  TryStmt |                  // Блок обработки исключений
  AwaitStmt { AwaitExpr } |  // Оператор Ждать
  ContinueStmt |             // Оператор Продолжить
  BreakStmt |                // Оператор Прервать
  GotoStmt |                 // Оператор Перейти
  AddHandlerStmt |           // Оператор ДобавитьОбработчик
  RemoveHandlerStmt |        // Оператор УдалитьОбработчик
  ReturnStmt |               // Оператор Возврат
  RaiseStmt |                // Оператор ВызватьИсключение
  AssignmentStmt |           // Присваивание
  CallStmt |                 // Вызов метода (проверяется перед ExecuteStmt, чтобы избежать конфликта с Объект.Выполнить())
  ExecuteStmt                // Оператор Выполнить
}

// Оператор вызова метода: переменная или свойство объекта с аргументами
// Поддерживает цепочки вызовов: Объект.Метод1().Метод2()
CallStmt {
  !assign
  VariableName
  // Базовая цепочка доступа (свойства/индексы)
  (memberAccess | indexAccess)*
  // Вызовы методов в цепочке:
  //   Объект.Метод1().Метод2()
  // Представляем как ArgList + продолжение цепочки доступа, повторяемое несколько раз.
  (ArgList (memberAccess | indexAccess)*)*
  // Финальный вызов метода
  ArgList
}

// Условный оператор: Если ... Тогда ... ИначеЕсли ... Тогда ... Иначе ... КонецЕсли
IfStmt {
  namedKw<"if", "Если">
  Condition { expression }
  namedKw<"then", "Тогда">
  Block?
  ElseIfClause {
    namedKw<"elseIf", "ИначеЕсли">
    Condition { expression }
    namedKw<"then", "Тогда">
    Block?
  }*
  ElseClause {
    namedKw<"else", "Иначе">
    Block?
  }?
  namedKw<"endIf", "КонецЕсли">
}

// Цикл пока: Пока ... Цикл ... КонецЦикла
WhileStmt {
  namedKw<"while", "Пока">
  Condition { expression }
  namedKw<"do", "Цикл">
  Block?
  namedKw<"endDo", "КонецЦикла">
}

// Цикл для: может быть двух видов:
// 1. Для Каждого ... Из ... (перебор коллекции)
// 2. Для ... = ... По ... (цикл с счетчиком)
ForEachStmt {
  namedKw<"for", "Для">
  namedKw<"each", "Каждого">
  VariableName
  namedKw<"in", "Из">
  Collection { expression }
  namedKw<"do", "Цикл">
  Block?
  namedKw<"endDo", "КонецЦикла">
}
ForStmt {
  namedKw<"for", "Для">
  VariableName
  "="
  Start { expression }
  namedKw<"to", "По">
  End { expression }
  namedKw<"do", "Цикл">
  Block?
  namedKw<"endDo", "КонецЦикла">
}

// Блок обработки исключений: Попытка ... Исключение ... КонецПопытки
TryStmt {
  namedKw<"try", "Попытка">
  Block?
  namedKw<"except", "Исключение">
  Block?
  namedKw<"endTry", "КонецПопытки">
}

// Оператор возврата из функции/процедуры: Возврат [значение]
ReturnStmt {
  namedKw<"return", "Возврат">
  Expression { expression }?
}

// Оператор вызова исключения: ВызватьИсключение [значение] или ВызватьИсключение(параметры)
// Форма со скобками требует минимум 2 параметра для различения от ParenthesizedExpr
RaiseStmt {
  namedKw<"raise", "ВызватьИсключение"> (
    "(" expression "," commaSep<expression> ")" |
    Expression { expression }
  )?
}

// Оператор выполнения выражения: Выполнить выражение
// Не распознается после точки (чтобы не конфликтовать с CallStmt: Объект.Выполнить())
ExecuteStmt {
  !member
  namedKw<"execute", "Выполнить">
  Expression { expression }
}

// Оператор продолжения цикла: Продолжить (переход к следующей итерации)
ContinueStmt {
  namedKw<"continue", "Продолжить">
}

// Оператор прерывания цикла: Прервать (выход из цикла)
BreakStmt {
  namedKw<"break", "Прервать">
}

// Оператор перехода: Перейти ~метка
GotoStmt {
  namedKw<"goto", "Перейти">
  "~"
  LabelName { identifier }
}

// Метка для оператора перехода: ~метка:
LabelStmt {
  "~"
  LabelName { identifier }
  ":"
}

// Оператор добавления обработчика события: ДобавитьОбработчик событие, обработчик
AddHandlerStmt {
  namedKw<"addHandler", "ДобавитьОбработчик">
  Event { expression }
  ","
  Handler { expression }
}

// Оператор удаления обработчика события: УдалитьОбработчик событие, обработчик
RemoveHandlerStmt {
  namedKw<"removeHandler", "УдалитьОбработчик">
  Event { expression }
  ","
  Handler { expression }
}

// Присваивание значения переменной: переменная = выражение
// Поддерживает присваивание простым переменным, свойствам объектов и элементам массивов
// Разворачивается напрямую: VariableName с опциональными memberAccess и indexAccess
AssignmentStmt {
  !assign
  VariableName
  // Базовая цепочка доступа (свойства/индексы)
  (memberAccess | indexAccess)*
  // Вызовы методов в левой части присваивания:
  //   Объект.Метод1().Метод2().Свойство = ...
  // Представляем как ArgList + продолжение цепочки доступа, повторяемое несколько раз.
  (ArgList (memberAccess | indexAccess)*)*
  AssignOp { "=" }
  Expression { expression }
}

// Выражение: различные типы выражений языка
expression {
  literal |                        // Литерал (число, строка, дата, булево значение и т.д.)
  VariableName |                   // Идентификатор (переменная)
  NewExpr |                        // Создание нового объекта
  TernaryExpr |                    // Тернарное выражение
  ParenthesizedExpr |              // Выражение в скобках
  CallExpr |                       // Вызов функции/метода
  BinaryExpr |                     // Бинарное выражение (операции с двумя операндами)
  MemberExpr |                     // Доступ к свойству или элементу массива
  AwaitExpr |                      // Асинхронное выражение
  UnaryExpr                        // Унарное выражение
}

// Вызов функции/метода: выражение со списком аргументов
CallExpr {
  expression !call ArgList
}

// Бинарное выражение: операции с двумя операндами
BinaryExpr {
  expression !times (divide | op<Arith, "%" | "*">) expression |
  expression !plus op<Arith, "+" | "-"> expression |
  expression !rel op<Compare, ">=" | "<=" | ">" | "<"> expression |
  expression !equal op<Compare, "=" | "<>"> expression |
  expression !and op<Logic, namedKw<"and", "И">> expression |
  expression !or op<Logic, namedKw<"or", "ИЛИ">> expression
}

// Асинхронное выражение: Ждать выражение
AwaitExpr {
  !prefix namedKw<"await", "Ждать"> expression
}

// Унарное выражение: НЕ выражение или отрицание числа
UnaryExpr {
  !prefix (op<Logic, namedKw<"not", "НЕ">> | op<Arith, "-">) expression
}

// Выражение в скобках: (выражение)
ParenthesizedExpr {
  "(" expression ")"
}

// Доступ к свойству объекта или элементу массива: выражение.свойство или выражение[индекс]
MemberExpr {
  expression !member (memberAccess | indexAccess)
}

// Имя переменной: идентификатор
VariableName { identifier }

// Доступ к свойству объекта: .свойство
memberAccess { "." PropertyName { identifier } }

// Доступ к элементу массива или свойству по строке: [индекс] или ["свойство"]
indexAccess { "[" Index { expression } "]" }

// Список аргументов: разделенные запятыми выражения в скобках
ArgList { "(" commaSep<expression> ")" }

// Создание нового объекта: Новый Тип, Новый Тип(параметры) или Новый(конструктор, параметры)
NewExpr {
  namedKw<"new", "Новый"> !newExpr TypeName { identifier } ArgList? |
  namedKw<"new", "Новый"> "(" TypeName {expression} ("," expression)* ")"
}

// Тернарное выражение: ?(условие, значение_если_истина, значение_если_ложь)
TernaryExpr {
  "?("
  Condition { expression }
  ","
  TrueCause { expression }
  ","
  FalseCause { expression }
  ")"
}

// Литерал: различные типы константных значений
literal {
  Number |                                    // Числовой литерал
  MultilineString |
  String |                                    // Строковый литерал (включая многострочный)
  Date |                                      // Литерал даты
  namedKw<"true", "Истина"> |                 // Булево значение Истина
  namedKw<"false", "Ложь"> |                  // Булево значение Ложь
  namedKw<"undefined", "Неопределено"> |      // Значение Неопределено
  @specialize[@name=null]<identifier, "Null"> // Значение Null
}

// --- Вспомогательные правила для ключевых слов (MVP: каноническое написание RU/EN) ---

// Именованное ключевое слово: аналогично kw, но с явным именем в AST
namedKw<termEn, termRu> {
  @specialize[@name={termEn}]<identifier, termEn | termRu >
}

op[@name={name} "Op"]<name, body> { body }

// Вспомогательное правило: разделенный запятыми список элементов (может быть пустым)
commaSep<content> {
  "" | content ("," content?)*
}

// Вспомогательное правило: разделенный запятыми список элементов (минимум один элемент)
commaSep1<content> {
  content ("," content)*
}

@detectDelim

